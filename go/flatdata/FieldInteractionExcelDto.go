// Code generated by fbsgen. DO NOT EDIT.
// Package flatdata contains generated code for FlatBuffers schema
package flatdata

import (
	fbsutils "github.com/arisu-archive/bluearchive-fbs-utils"
	flatbuffers "github.com/google/flatbuffers/go"
)

// FieldInteractionExcelDto represents a FlatBuffers table
type FieldInteractionExcelDto struct {
	fbsutils.FlatBuffer
	NegateCondition          []bool                 `json:"negate_condition"`
	ConditionClass           FieldConditionClass    `json:"condition_class"`
	InteractionType          []FieldInteractionType `json:"interaction_type"`
	FieldSeasonId            int64                  `json:"field_season_id"`
	FieldDateId              int64                  `json:"field_date_id"`
	ShowEmoji                bool                   `json:"show_emoji"`
	ConditionIndex           []int64                `json:"condition_index"`
	InteractionId            []int64                `json:"interaction_id"`
	ConditionClassParameters []int64                `json:"condition_class_parameters"`
	UniqueId                 int64                  `json:"unique_id"`
	ConditionId              []int64                `json:"condition_id"`
	ConditionType            []FieldConditionType   `json:"condition_type"`
	KeywordLocalize          string                 `json:"keyword_localize"`
	OnceOnly                 bool                   `json:"once_only"`
}

// MarshalModel marshals the struct into flatbuffers offset
func (t *FieldInteractionExcelDto) MarshalModel(b *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("FieldInteraction"))
	}
	FieldInteractionExcelStart(b)
	FieldInteractionExcelStartNegateConditionVector(b, len(t.NegateCondition))
	for i := range len(t.NegateCondition) {
		b.PrependBool(t.NegateCondition[len(t.NegateCondition)-i-1])
	}
	FieldInteractionExcelAddNegateCondition(b, b.EndVector(len(t.NegateCondition)))
	FieldInteractionExcelAddConditionClass(b, fbsutils.Convert(t.ConditionClass, t.FlatBuffer.TableKey))
	FieldInteractionExcelStartInteractionTypeVector(b, len(t.InteractionType))
	for i := range len(t.InteractionType) {
		b.PrependInt32(fbsutils.Convert(int32(t.InteractionType[len(t.InteractionType)-i-1]), t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddInteractionType(b, b.EndVector(len(t.InteractionType)))
	FieldInteractionExcelAddFieldSeasonId(b, fbsutils.Convert(t.FieldSeasonId, t.FlatBuffer.TableKey))
	FieldInteractionExcelAddFieldDateId(b, fbsutils.Convert(t.FieldDateId, t.FlatBuffer.TableKey))
	FieldInteractionExcelAddShowEmoji(b, t.ShowEmoji)
	FieldInteractionExcelStartConditionIndexVector(b, len(t.ConditionIndex))
	for i := range len(t.ConditionIndex) {
		b.PrependInt64(fbsutils.Convert(t.ConditionIndex[len(t.ConditionIndex)-i-1], t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddConditionIndex(b, b.EndVector(len(t.ConditionIndex)))
	FieldInteractionExcelStartInteractionIdVector(b, len(t.InteractionId))
	for i := range len(t.InteractionId) {
		b.PrependInt64(fbsutils.Convert(t.InteractionId[len(t.InteractionId)-i-1], t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddInteractionId(b, b.EndVector(len(t.InteractionId)))
	FieldInteractionExcelStartConditionClassParametersVector(b, len(t.ConditionClassParameters))
	for i := range len(t.ConditionClassParameters) {
		b.PrependInt64(fbsutils.Convert(t.ConditionClassParameters[len(t.ConditionClassParameters)-i-1], t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddConditionClassParameters(b, b.EndVector(len(t.ConditionClassParameters)))
	FieldInteractionExcelAddUniqueId(b, fbsutils.Convert(t.UniqueId, t.FlatBuffer.TableKey))
	FieldInteractionExcelStartConditionIdVector(b, len(t.ConditionId))
	for i := range len(t.ConditionId) {
		b.PrependInt64(fbsutils.Convert(t.ConditionId[len(t.ConditionId)-i-1], t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddConditionId(b, b.EndVector(len(t.ConditionId)))
	FieldInteractionExcelStartConditionTypeVector(b, len(t.ConditionType))
	for i := range len(t.ConditionType) {
		b.PrependInt32(fbsutils.Convert(int32(t.ConditionType[len(t.ConditionType)-i-1]), t.FlatBuffer.TableKey))
	}
	FieldInteractionExcelAddConditionType(b, b.EndVector(len(t.ConditionType)))
	FieldInteractionExcelAddKeywordLocalize(b, b.CreateString(fbsutils.Convert(t.KeywordLocalize, t.FlatBuffer.TableKey)))
	FieldInteractionExcelAddOnceOnly(b, t.OnceOnly)
	return FieldInteractionExcelEnd(b)
}

// Marshal marshals the struct into a FlatBuffers buffer
func (t *FieldInteractionExcelDto) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(t.MarshalModel(b))
	return b.FinishedBytes(), nil
}

// UnmarshalMessage unmarshals the struct from a FlatBuffers buffer
func (t *FieldInteractionExcelDto) UnmarshalMessage(e *FieldInteractionExcel) error {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("FieldInteraction"))
	}
	t.NegateCondition = make([]bool, e.NegateConditionLength())
	for i := range e.NegateConditionLength() {
		t.NegateCondition[i] = e.NegateCondition(i)
	}
	t.ConditionClass = FieldConditionClass(fbsutils.Convert(int32(e.ConditionClass()), t.FlatBuffer.TableKey))
	t.InteractionType = make([]FieldInteractionType, e.InteractionTypeLength())
	for i := range e.InteractionTypeLength() {
		t.InteractionType[i] = FieldInteractionType(fbsutils.Convert(int32(e.InteractionType(i)), t.FlatBuffer.TableKey))
	}
	t.FieldSeasonId = fbsutils.Convert(e.FieldSeasonId(), t.FlatBuffer.TableKey)
	t.FieldDateId = fbsutils.Convert(e.FieldDateId(), t.FlatBuffer.TableKey)
	t.ShowEmoji = e.ShowEmoji()
	t.ConditionIndex = make([]int64, e.ConditionIndexLength())
	for i := range e.ConditionIndexLength() {
		t.ConditionIndex[i] = fbsutils.Convert(e.ConditionIndex(i), t.FlatBuffer.TableKey)
	}
	t.InteractionId = make([]int64, e.InteractionIdLength())
	for i := range e.InteractionIdLength() {
		t.InteractionId[i] = fbsutils.Convert(e.InteractionId(i), t.FlatBuffer.TableKey)
	}
	t.ConditionClassParameters = make([]int64, e.ConditionClassParametersLength())
	for i := range e.ConditionClassParametersLength() {
		t.ConditionClassParameters[i] = fbsutils.Convert(e.ConditionClassParameters(i), t.FlatBuffer.TableKey)
	}
	t.UniqueId = fbsutils.Convert(e.UniqueId(), t.FlatBuffer.TableKey)
	t.ConditionId = make([]int64, e.ConditionIdLength())
	for i := range e.ConditionIdLength() {
		t.ConditionId[i] = fbsutils.Convert(e.ConditionId(i), t.FlatBuffer.TableKey)
	}
	t.ConditionType = make([]FieldConditionType, e.ConditionTypeLength())
	for i := range e.ConditionTypeLength() {
		t.ConditionType[i] = FieldConditionType(fbsutils.Convert(int32(e.ConditionType(i)), t.FlatBuffer.TableKey))
	}
	t.KeywordLocalize = fbsutils.Convert(string(e.KeywordLocalize()), t.FlatBuffer.TableKey)
	t.OnceOnly = e.OnceOnly()
	return nil
}

// Unmarshal unmarshals the struct from a FlatBuffers buffer
func (t *FieldInteractionExcelDto) Unmarshal(data []byte) error {
	root := GetRootAsFieldInteractionExcel(data, 0)
	err := t.UnmarshalMessage(root)
	if err != nil {
		return err
	}
	return nil
}

// Name returns the name of the flatbuffer table name
func (FieldInteractionExcelDto) FlatDataName() string {
	return "FieldInteractionExcel"
}
