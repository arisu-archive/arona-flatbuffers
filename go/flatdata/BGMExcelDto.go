// Code generated by fbsgen. DO NOT EDIT.
// Package flatdata contains generated code for FlatBuffers schema
package flatdata

import (
	fbsutils "github.com/arisu-archive/bluearchive-fbs-utils"
	flatbuffers "github.com/google/flatbuffers/go"
)

// BGMExcelDto represents a FlatBuffers table
type BGMExcelDto struct {
	fbsutils.FlatBuffer
	Id                int64     `json:"id"`
	Nation            []Nation  `json:"nation"`
	Path              []string  `json:"path"`
	Volume            []float32 `json:"volume"`
	LoopStartTime     []float32 `json:"loop_start_time"`
	LoopEndTime       []float32 `json:"loop_end_time"`
	LoopTranstionTime []float32 `json:"loop_transtion_time"`
	LoopOffsetTime    []float32 `json:"loop_offset_time"`
}

// MarshalModel marshals the struct into flatbuffers offset
func (t *BGMExcelDto) MarshalModel(b *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("BGM"))
	}
	BGMExcelStart(b)
	BGMExcelAddId(b, fbsutils.Convert(t.Id, t.FlatBuffer.TableKey))
	BGMExcelStartNationVector(b, len(t.Nation))
	for i := range len(t.Nation) {
		b.PrependInt32(fbsutils.Convert(int32(fbsutils.Convert(t.Nation[len(t.Nation)-i-1], t.FlatBuffer.TableKey)), t.FlatBuffer.TableKey))
	}
	BGMExcelAddNation(b, b.EndVector(len(t.Nation)))
	BGMExcelStartPathVector(b, len(t.Path))
	for i := range len(t.Path) {
		b.PrependUOffsetT(fbsutils.Convert(b.CreateString(t.Path[len(t.Path)-i-1]), t.FlatBuffer.TableKey))
	}
	BGMExcelAddPath(b, b.EndVector(len(t.Path)))
	BGMExcelStartVolumeVector(b, len(t.Volume))
	for i := range len(t.Volume) {
		b.PrependFloat32(fbsutils.Convert(t.Volume[len(t.Volume)-i-1], t.FlatBuffer.TableKey))
	}
	BGMExcelAddVolume(b, b.EndVector(len(t.Volume)))
	BGMExcelStartLoopStartTimeVector(b, len(t.LoopStartTime))
	for i := range len(t.LoopStartTime) {
		b.PrependFloat32(fbsutils.Convert(t.LoopStartTime[len(t.LoopStartTime)-i-1], t.FlatBuffer.TableKey))
	}
	BGMExcelAddLoopStartTime(b, b.EndVector(len(t.LoopStartTime)))
	BGMExcelStartLoopEndTimeVector(b, len(t.LoopEndTime))
	for i := range len(t.LoopEndTime) {
		b.PrependFloat32(fbsutils.Convert(t.LoopEndTime[len(t.LoopEndTime)-i-1], t.FlatBuffer.TableKey))
	}
	BGMExcelAddLoopEndTime(b, b.EndVector(len(t.LoopEndTime)))
	BGMExcelStartLoopTranstionTimeVector(b, len(t.LoopTranstionTime))
	for i := range len(t.LoopTranstionTime) {
		b.PrependFloat32(fbsutils.Convert(t.LoopTranstionTime[len(t.LoopTranstionTime)-i-1], t.FlatBuffer.TableKey))
	}
	BGMExcelAddLoopTranstionTime(b, b.EndVector(len(t.LoopTranstionTime)))
	BGMExcelStartLoopOffsetTimeVector(b, len(t.LoopOffsetTime))
	for i := range len(t.LoopOffsetTime) {
		b.PrependFloat32(fbsutils.Convert(t.LoopOffsetTime[len(t.LoopOffsetTime)-i-1], t.FlatBuffer.TableKey))
	}
	BGMExcelAddLoopOffsetTime(b, b.EndVector(len(t.LoopOffsetTime)))
	return BGMExcelEnd(b)
}

// Marshal marshals the struct into a FlatBuffers buffer
func (t *BGMExcelDto) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	FinishBGMExcelBuffer(b, t.MarshalModel(b))
	return b.FinishedBytes(), nil
}

// UnmarshalMessage unmarshals the struct from a FlatBuffers buffer
func (t *BGMExcelDto) UnmarshalMessage(e *BGMExcel) error {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("BGM"))
	}
	t.Id = fbsutils.Convert(e.Id(), t.FlatBuffer.TableKey)
	t.Nation = make([]Nation, e.NationLength())
	for i := range e.NationLength() {
		t.Nation[i] = Nation(fbsutils.Convert(int32(e.Nation(i)), t.FlatBuffer.TableKey))
	}
	t.Path = make([]string, e.PathLength())
	for i := range e.PathLength() {
		t.Path[i] = string(e.Path(i))
	}
	t.Volume = make([]float32, e.VolumeLength())
	for i := range e.VolumeLength() {
		t.Volume[i] = e.Volume(i)
	}
	t.LoopStartTime = make([]float32, e.LoopStartTimeLength())
	for i := range e.LoopStartTimeLength() {
		t.LoopStartTime[i] = e.LoopStartTime(i)
	}
	t.LoopEndTime = make([]float32, e.LoopEndTimeLength())
	for i := range e.LoopEndTimeLength() {
		t.LoopEndTime[i] = e.LoopEndTime(i)
	}
	t.LoopTranstionTime = make([]float32, e.LoopTranstionTimeLength())
	for i := range e.LoopTranstionTimeLength() {
		t.LoopTranstionTime[i] = e.LoopTranstionTime(i)
	}
	t.LoopOffsetTime = make([]float32, e.LoopOffsetTimeLength())
	for i := range e.LoopOffsetTimeLength() {
		t.LoopOffsetTime[i] = e.LoopOffsetTime(i)
	}
	return nil
}

// Unmarshal unmarshals the struct from a FlatBuffers buffer
func (t *BGMExcelDto) Unmarshal(data []byte) error {
	root := GetRootAsBGMExcel(data, 0)
	err := t.UnmarshalMessage(root)
	if err != nil {
		return err
	}
	return nil
}

// Name returns the name of the flatbuffer table name
func (BGMExcelDto) FlatDataName() string {
	return "BGMExcel"
}
